package com.mxc.contract.lps.dispatcher.handler;

import java.util.Map;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;
import java.util.concurrent.TimeUnit;

import com.google.common.collect.Maps;

import com.mxc.contract.lps.dispatcher.emitter.AllUserDataV2Emitter;
import com.mxc.contract.lps.dispatcher.enums.BusinessType;

import com.mxc.contract.lps.dispatcher.utils.ThreadUtils;

import lombok.extern.slf4j.Slf4j;
import lombok.val;

import com.alibaba.fastjson.JSON;
import org.apache.curator.shaded.com.google.common.util.concurrent.RateLimiter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.concurrent.CustomizableThreadFactory;
import org.springframework.stereotype.Component;

import com.mxc.contract.core.event.users.OrderChangeEvent;
import com.mxc.contract.core.model.Contract;
import com.mxc.contract.lps.dispatcher.consumer.BaseEventWrap;
import com.mxc.contract.lps.dispatcher.emitter.AllUserDataEmitter;
import com.mxc.contract.lps.dispatcher.emitter.UserDataBySymbolEmitter;
import com.mxc.contract.lps.dispatcher.emitter.UserDataEmitter;
import com.mxc.contract.lps.dispatcher.manager.CopySubManager;
import com.mxc.contract.lps.dispatcher.model.dto.LpsOrderChangeEvent;
import com.mxc.contract.lps.dispatcher.utils.CommonConfigUtil;
import com.mxc.contract.service.MarketCacheService;

import javax.annotation.PostConstruct;

@Slf4j
@Component
public class UserOrderChangeEventHandler extends AbstractEventHandler {

    //详见 AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement.inject
    private final AllUserDataEmitter allUserDataEmitter;
    private final UserDataEmitter userDataEmitter;
    private final UserDataBySymbolEmitter userDataBySymbolEmitter;

    private final CopySubManager copySubManager;
    /*
        private final ExecutorService exec2;
        private final ExecutorService exec3;*/
    private final ThreadPoolExecutor orderChangeExecutor;
    private final int orderChangeExecutorQueueCapacity;
    private final ExecutorService exec4;

    @Autowired(required = false)
    private AllUserDataV2Emitter allUserDataV2Emitter;

    @Value("${mxc.contract.events.UserOrderChangeEventHandler.thread.num:10}")
    private Long num = 10L;
    private Map<Long, ExecutorService> allUserExec;

    public UserOrderChangeEventHandler(MarketCacheService marketCacheService, AllUserDataEmitter allUserDataEmitter,
        UserDataEmitter userDataEmitter,
        UserDataBySymbolEmitter userDataBySymbolEmitter, CommonConfigUtil configUtil,
        CopySubManager copySubManager,
        @Value("${mxc.contract.events.UserOrderChangeEventHandler.executor.coreSize:4}") int orderChangeExecutorCoreSize,
        @Value("${mxc.contract.events.UserOrderChangeEventHandler.executor.maxSize:16}") int orderChangeExecutorMaxSize,
        @Value("${mxc.contract.events.UserOrderChangeEventHandler.executor.queueCapacity:2048}") int orderChangeExecutorQueueCapacity) {
        super(marketCacheService, configUtil);
        this.allUserDataEmitter = allUserDataEmitter;
        this.userDataEmitter = userDataEmitter;
        this.userDataBySymbolEmitter = userDataBySymbolEmitter;
        this.copySubManager = copySubManager;
        this.orderChangeExecutorQueueCapacity = orderChangeExecutorQueueCapacity;
        //预计100M
        if (num != null) {
            initAllUserExec();
        }        //预计100M
        LinkedBlockingQueue<Runnable> queue = new LinkedBlockingQueue<>(orderChangeExecutorQueueCapacity);
        CallerRunsPolicy callerRunsPolicy = new CallerRunsPolicy();
        this.orderChangeExecutor = new ThreadPoolExecutor(orderChangeExecutorCoreSize, orderChangeExecutorMaxSize, 60L,
            TimeUnit.SECONDS, queue, new CustomizableThreadFactory("orderChange-handler-"), (r, executor) -> {
            int queueSize = executor.getQueue().size();
            log.error(
                "orderChangeExecutor rejected task. queueSize={}, poolSize={}, activeCount={}, taskCount={}", queueSize,
                executor.getPoolSize(), executor.getActiveCount(), executor.getTaskCount());
            callerRunsPolicy.rejectedExecution(r, executor);
        });
        log.info(
            "Initialized orderChangeExecutor with coreSize={}, maxSize={}, queueCapacity={}",
            orderChangeExecutorCoreSize,
            orderChangeExecutorMaxSize, orderChangeExecutorQueueCapacity);
        this.exec4 = ThreadUtils.newSingleThreadExecutor("orderChange-handler04-", 102400);
    }

    @PostConstruct
    public void initAllUserExec() {
        allUserExec = Maps.newHashMap();
        for (long i = 0; i < num; i++) {
            allUserExec.put(i, ThreadUtils.newSingleThreadExecutor("orderChange-handler-allUser-" + i + "-", 10240));
        }
    }

    private void submitOrderChangeTask(Runnable task) {
        if (Objects.nonNull(orderChangeExecutor)) {
            int queueSize = orderChangeExecutor.getQueue().size();
            if (orderChangeExecutorQueueCapacity > 0 && queueSize >= orderChangeExecutorQueueCapacity * 4 / 5) {
                log.warn("orderChangeExecutor queue usage high. size={}, capacity={}", queueSize,
                    orderChangeExecutorQueueCapacity);
            }
        }
        CompletableFuture.runAsync(task, orderChangeExecutor);
    }

    @Override
    public void onEvent(BaseEventWrap event, long sequence, boolean endOfBatch) throws Exception {

        val data = event.getData();
        if (data instanceof OrderChangeEvent) {
            if (allUserExec == null) {
                initAllUserExec();
            }
            submitOrderChangeTask(() -> {
                OrderChangeEvent origin = (OrderChangeEvent) data;
                Contract contract = getContract(origin.getOrder().getContractId());
                if (Objects.isNull(contract)) {
                    log.error("OrderChangeEventHandler 出现脏数据contract is null, origin={}", JSON.toJSON(origin));
                    return;
                }
                Long uid = origin.getOrder().getUid();
                if (allUserDataV2Emitter != null) {
                    CompletableFuture.runAsync(() -> {
                        // 过滤 做市商 与 压测流量
                        if (marketCacheService.isMarketMaker(uid) || Boolean.TRUE.equals(contract.getIsPressure())) {
                            return;
                        }
                        allUserDataV2Emitter.emit(origin, uid);
                    }, exec4);
                }
                Integer businessType = copySubManager.getBusinessType(uid);
                CompletableFuture.runAsync(() ->
                {
                    allUserDataEmitter.emit(new LpsOrderChangeEvent(origin, contract, businessType));

                }, allUserExec.get(uid % num));
            });
        }
    }
}
